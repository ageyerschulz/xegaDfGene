#
# (c) 2021 Andreas Geyer-Schulz
#          Simple Genetic Algorithm in R. V 0.1
#          Layer: Population-level functions.
#                 Independent of gene representation.
#                 The replication mechanism and its variants
#          Package: xegaPopulation.
#

#' Replicates a gene (differential evolution).
#'
#' @description \code{xegaDfReplicateGeneDE()} replicates a gene. Replication
#'              is the reproduction function which uses crossover and
#'              mutation. The control flow of differential evolution 
#'              is as follows:
#'              \itemize{
#'              \item A target gene is selected from the population.
#'              \item A mutant gene is generated by differential mutation.
#'              \item The gene and the mutant gene are crossed to get a 
#'                    new gene.
#'              \item The gene is accepted if it is at least as good 
#'                    as the target gene.
#'              }
#'
#' @details For \code{selection="UniformP"},
#'          for \code{crossover="UPCrossGene"} and
#'          for \code{accept="Best"}
#'          this is 
#'          the algorithm of Price, Storn and Lampinen (2005), page 41.
#'
#' @param pop    Population of real-coded genes.
#' @param fit    Fitness vector.
#' @param lF     Local configuration of the genetic algorithm.
#'
#' @return A list of one gene.
#'
#' @family Replication
#'
#' @references
#' Price, Kenneth V., Storn, Rainer M. and Lampinen, Jouni A. (2005)
#' The Differential Evolution Algorithm (Chapter 2), pp. 37-134.
#' In: Differential Evolution. A Practical Approach to Global Optimization.
#' Springer, Berlin.
#' <doi:10.1007/3-540-31306-0>
#'
#' @examples
#' pop10<-lapply(rep(0,10), function(x) xegaDfGene::xegaDfInitGene(lFxegaDfGene))
#' epop10<-lapply(pop10, lFxegaDfGene$EvalGene, lF=lFxegaDfGene)
#' fit10<-unlist(lapply(epop10, function(x) {x$fit}))
#' newgenes<-xegaDfReplicateGeneDE(pop10, fit10, lFxegaDfGene)
#' @importFrom xegaSelectGene parm
#' @export
xegaDfReplicateGeneDE<- function(pop, fit, lF)
{
targetGene<-pop[[lF$SelectGene(fit, lF)]]
gene0<-pop[[lF$SelectGene(fit, lF)]]
gene1<-pop[[lF$SelectGene(fit, lF)]]
gene2<-pop[[lF$SelectGene(fit, lF)]]
trialGene<-lF$CrossGene(targetGene,lF$MutateGene(gene0, gene1, gene2, lF))[[1]]
t1<-lF$EvalGene(trialGene, lF)
    lF$trialGene<-parm(t1)
    OperatorPipeline<-function(g, lF) {lF$trialGene()}   
    return(list(lF$Accept(OperatorPipeline, targetGene, lF)))
}

#' Replicates a gene pipeline (differential evolution).
#'
#' @description \code{xegaDfReplicateGeneDEPipeline()} replicates 
#'              a gene pipeline. Replication
#'              is the reproduction function which uses crossover and
#'              mutation. The control flow of differential evolution 
#'              is as follows:
#'              \itemize{
#'              \item A target gene is selected from the population.
#'              \item A mutant gene is generated by differential mutation.
#'              \item The gene and the mutant gene are crossed to get a 
#'                    new gene.
#'              \item The gene is accepted if it is at least as good 
#'                    as the target gene.
#'              }
#'              The execution is shifted to the evaluation phase.
#'
#' @details For \code{selection="UniformP"},
#'          for \code{crossover="UPCrossGene"} and
#'          for \code{accept="Best"}
#'          this is 
#'          the algorithm of Price, Storn and Lampinen (2005), page 41.
#'
#' @param pop    Population of real-coded genes.
#' @param fit    Fitness vector.
#' @param lF     Local configuration of the genetic algorithm.
#'
#' @return A list of differential evolution pipelines.
#'
#' @family Replication
#'
#' @references
#' Price, Kenneth V., Storn, Rainer M. and Lampinen, Jouni A. (2005)
#' The Differential Evolution Algorithm (Chapter 2), pp. 37-134.
#' In: Differential Evolution. A Practical Approach to Global Optimization.
#' Springer, Berlin.
#' <doi:10.1007/3-540-31306-0>
#'
#' @examples
#' pop10<-lapply(rep(0,10), function(x) xegaDfGene::xegaDfInitGene(lFxegaDfGene))
#' epop10<-lapply(pop10, lFxegaDfGene$EvalGene, lF=lFxegaDfGene)
#' fit10<-unlist(lapply(epop10, function(x) {x$fit}))
#' newgenes<-xegaDfReplicateGeneDEPipeline(pop10, fit10, lFxegaDfGene)
#' @importFrom xegaSelectGene parm
#' @export
xegaDfReplicateGeneDEPipeline<- function(pop, fit, lF)
{
targetGene<-pop[[lF$SelectGene(fit, lF)]]
gene0<-pop[[lF$SelectGene(fit, lF)]]
gene1<-pop[[lF$SelectGene(fit, lF)]]
gene2<-pop[[lF$SelectGene(fit, lF)]]
Pipeline<-function(lF)
{
trialGene<-lF$CrossGene(targetGene,lF$MutateGene(gene0, gene1, gene2, lF))[[1]]
t1<-lF$EvalGene(trialGene, lF)
    lF$trialGene<-parm(t1)
    OperatorPipeline<-function(g, lF) {lF$trialGene()}   
    return(lF$Accept(OperatorPipeline, targetGene, lF))
}
# force
a<-targetGene
a<-gene0
a<-gene1
a<-gene2
return(Pipeline)
}

#' Configure the replication function of a genetic algorithm.
#'
#' @description \code{xegaDfReplicationFactory()} implements the selection
#'              of a replication method. 
#'
#'              Current support:
#'
#'              \enumerate{
#'              \item "DE" returns \code{xegaDfReplicateGeneDE()}.
#'              }
#'
#' @param method A string specifying the replication function.
#'
#' @return A replication function for genes.
#'
#' @family Configuration
#'
#' @examples
#' pop10<-lapply(rep(0,10), function(x) xegaDfInitGene(lFxegaDfGene))
#' epop10<-lapply(pop10, lFxegaDfGene$EvalGene, lF=lFxegaDfGene)
#' fit10<-unlist(lapply(epop10, function(x) {x$fit}))
#' Replicate<-xegaDfReplicationFactory("DE")
#' newgenes2<-Replicate(pop10, fit10, lFxegaDfGene)
#' @export
xegaDfReplicationFactory<-function(method="DE") {
if (method=="DE") {f<- xegaDfReplicateGeneDE}
if (method=="DEPipeline") {f<- xegaDfReplicateGeneDEPipeline}
if (!exists("f", inherits=FALSE))
        {stop("sgde Replication label ", method, " does not exist")}
return(f)
}

